---
source: editoast_derive/src/model.rs
---
// Source
// -----------------------------------------------------------------------------

#[derive(Clone, Model)]
#[model(table = database::tables::osrd_infra_document)]
#[model(row(type_name = "DocumentRow", derive(Debug)))]
#[model(changeset(type_name = "DocumentChangeset", public, derive(Debug)))]
#[model(gen(ops = crud, batch_ops = crud, list))]
struct Document {
    #[model(column = "id", preferred, primary)]
    id_: i64,
    #[model(identifier, json)]
    content_type: String,
    data: Vec<u8>,
}

// Macro expansion
// -----------------------------------------------------------------------------

#[automatically_derived]
impl crate::prelude::Model for Document {
    type Row = DocumentRow;
    type Changeset = DocumentChangeset;
    type Table = database::tables::osrd_infra_document::table;
}
#[doc(hidden)]
struct _DocumentField<M, T, Column>(core::marker::PhantomData<(M, T, Column)>);
impl Document {
    pub const ID_: _DocumentField<Document, i64, id> = _DocumentField(
        core::marker::PhantomData,
    );
    pub const CONTENT_TYPE: _DocumentField<
        Document,
        String,
        database::tables::osrd_infra_document::content_type,
    > = _DocumentField(core::marker::PhantomData);
    pub const DATA: _DocumentField<
        Document,
        Vec<u8>,
        database::tables::osrd_infra_document::data,
    > = _DocumentField(core::marker::PhantomData);
}
impl _DocumentField<Document, i64, id> {
    pub fn eq(&self, value: i64) -> crate::prelude::FilterSetting<Document> {
        use diesel::ExpressionMethods;
        crate::prelude::FilterSetting::new(id.eq(value))
    }
    pub fn eq_any(&self, values: Vec<i64>) -> crate::prelude::FilterSetting<Document> {
        use diesel::ExpressionMethods;
        crate::prelude::FilterSetting::new(id.eq_any(values))
    }
    pub fn asc(&self) -> crate::prelude::SortSetting<Document> {
        use diesel::ExpressionMethods;
        crate::prelude::SortSetting(Box::new(id.asc()))
    }
    pub fn desc(&self) -> crate::prelude::SortSetting<Document> {
        use diesel::ExpressionMethods;
        crate::prelude::SortSetting(Box::new(id.desc()))
    }
}
impl _DocumentField<
    Document,
    String,
    database::tables::osrd_infra_document::content_type,
> {
    pub fn eq(&self, value: String) -> crate::prelude::FilterSetting<Document> {
        use diesel::ExpressionMethods;
        let value: diesel_json::Json<String> = diesel_json::Json(value);
        crate::prelude::FilterSetting::new(
            database::tables::osrd_infra_document::content_type.eq(value),
        )
    }
    pub fn eq_any(
        &self,
        values: Vec<String>,
    ) -> crate::prelude::FilterSetting<Document> {
        use diesel::ExpressionMethods;
        let values: Vec<diesel_json::Json<String>> = values
            .into_iter()
            .map(|value| diesel_json::Json(value))
            .collect();
        crate::prelude::FilterSetting::new(
            database::tables::osrd_infra_document::content_type.eq_any(values),
        )
    }
    pub fn asc(&self) -> crate::prelude::SortSetting<Document> {
        use diesel::ExpressionMethods;
        crate::prelude::SortSetting(
            Box::new(database::tables::osrd_infra_document::content_type.asc()),
        )
    }
    pub fn desc(&self) -> crate::prelude::SortSetting<Document> {
        use diesel::ExpressionMethods;
        crate::prelude::SortSetting(
            Box::new(database::tables::osrd_infra_document::content_type.desc()),
        )
    }
}
impl _DocumentField<Document, Vec<u8>, database::tables::osrd_infra_document::data> {
    pub fn eq(&self, value: Vec<u8>) -> crate::prelude::FilterSetting<Document> {
        use diesel::ExpressionMethods;
        crate::prelude::FilterSetting::new(
            database::tables::osrd_infra_document::data.eq(value),
        )
    }
    pub fn eq_any(
        &self,
        values: Vec<Vec<u8>>,
    ) -> crate::prelude::FilterSetting<Document> {
        use diesel::ExpressionMethods;
        crate::prelude::FilterSetting::new(
            database::tables::osrd_infra_document::data.eq_any(values),
        )
    }
    pub fn asc(&self) -> crate::prelude::SortSetting<Document> {
        use diesel::ExpressionMethods;
        crate::prelude::SortSetting(
            Box::new(database::tables::osrd_infra_document::data.asc()),
        )
    }
    pub fn desc(&self) -> crate::prelude::SortSetting<Document> {
        use diesel::ExpressionMethods;
        crate::prelude::SortSetting(
            Box::new(database::tables::osrd_infra_document::data.desc()),
        )
    }
}
#[derive(diesel::Queryable, Debug)]
#[diesel(table_name = database::tables::osrd_infra_document)]
struct DocumentRow {
    #[diesel(column_name = "id")]
    id_: i64,
    #[diesel(column_name = "content_type")]
    content_type: diesel_json::Json<String>,
    #[diesel(column_name = "data")]
    data: Vec<u8>,
}
#[derive(
    Debug,
    Default,
    diesel::Queryable,
    diesel::AsChangeset,
    diesel::Insertable,
    Debug
)]
#[diesel(table_name = database::tables::osrd_infra_document)]
struct DocumentChangeset {
    #[diesel(deserialize_as = diesel_json::Json<String>, column_name = "content_type")]
    pub content_type: Option<diesel_json::Json<String>>,
    #[diesel(deserialize_as = Vec<u8>, column_name = "data")]
    pub data: Option<Vec<u8>>,
}
#[automatically_derived]
impl crate::prelude::Identifiable<(String)> for Document {
    fn get_id(&self) -> (String) {
        (self.content_type.clone())
    }
}
#[automatically_derived]
impl crate::prelude::Identifiable<(i64)> for Document {
    fn get_id(&self) -> (i64) {
        (self.id_.clone())
    }
}
#[automatically_derived]
impl crate::prelude::PreferredId<(i64)> for Document {}
#[automatically_derived]
impl From<DocumentRow> for Document {
    fn from(row: DocumentRow) -> Self {
        Self {
            id_: row.id_,
            content_type: row.content_type.0,
            data: row.data,
        }
    }
}
#[automatically_derived]
impl From<Document> for DocumentChangeset {
    fn from(model: Document) -> Self {
        Self {
            content_type: Some(diesel_json::Json(model.content_type)),
            data: Some(model.data),
        }
    }
}
impl DocumentChangeset {
    #[allow(unused)]
    #[must_use = "builder methods are intended to be chained"]
    pub fn content_type(mut self, content_type: String) -> Self {
        self.content_type = Some(diesel_json::Json(content_type));
        self
    }
    #[allow(unused)]
    #[must_use = "builder methods are intended to be chained"]
    pub fn data(mut self, data: Vec<u8>) -> Self {
        self.data = Some(data);
        self
    }
    #[allow(unused)]
    #[must_use = "builder methods are intended to be chained"]
    pub fn flat_content_type(mut self, content_type: Option<String>) -> Self {
        self.content_type = content_type
            .map(|content_type| diesel_json::Json(content_type));
        self
    }
    #[allow(unused)]
    #[must_use = "builder methods are intended to be chained"]
    pub fn flat_data(mut self, data: Option<Vec<u8>>) -> Self {
        self.data = data.map(|data| data);
        self
    }
}
#[automatically_derived]
impl crate::prelude::Exists<(String)> for Document {
    type Error = editoast_models::Error;
    #[tracing::instrument(
        name = "model:exists<Document>",
        skip_all,
        ret,
        err,
        fields(query_id)
    )]
    async fn exists(
        conn: &mut database::DbConnection,
        content_type: (String),
    ) -> std::result::Result<bool, Self::Error> {
        use diesel::prelude::*;
        use diesel_async::RunQueryDsl;
        use std::ops::DerefMut;
        use database::tables::osrd_infra_document::dsl;
        tracing::Span::current()
            .record("query_id", tracing::field::debug(&content_type));
        diesel::select(
                diesel::dsl::exists(
                    dsl::osrd_infra_document.filter(dsl::content_type.eq(content_type)),
                ),
            )
            .get_result(conn.write().await.deref_mut())
            .await
            .map_err(|e| Self::Error::from(editoast_models::Error::from(e)))
    }
}
#[automatically_derived]
impl crate::prelude::Exists<(i64)> for Document {
    type Error = editoast_models::Error;
    #[tracing::instrument(
        name = "model:exists<Document>",
        skip_all,
        ret,
        err,
        fields(query_id)
    )]
    async fn exists(
        conn: &mut database::DbConnection,
        id_: (i64),
    ) -> std::result::Result<bool, Self::Error> {
        use diesel::prelude::*;
        use diesel_async::RunQueryDsl;
        use std::ops::DerefMut;
        use database::tables::osrd_infra_document::dsl;
        tracing::Span::current().record("query_id", tracing::field::debug(&id_));
        diesel::select(
                diesel::dsl::exists(dsl::osrd_infra_document.filter(dsl::id.eq(id_))),
            )
            .get_result(conn.write().await.deref_mut())
            .await
            .map_err(|e| Self::Error::from(editoast_models::Error::from(e)))
    }
}
#[automatically_derived]
impl crate::prelude::Retrieve<(String)> for Document {
    type Error = editoast_models::Error;
    #[tracing::instrument(
        name = "model:retrieve<Document>",
        skip_all,
        err,
        fields(query_id)
    )]
    async fn retrieve(
        conn: database::DbConnection,
        content_type: (String),
    ) -> std::result::Result<Option<Document>, Self::Error> {
        use diesel::prelude::*;
        use diesel_async::RunQueryDsl;
        use database::tables::osrd_infra_document::dsl;
        use std::ops::DerefMut;
        tracing::Span::current()
            .record("query_id", tracing::field::debug(&content_type));
        dsl::osrd_infra_document
            .filter(dsl::content_type.eq(content_type))
            .select((dsl::id, dsl::content_type, dsl::data))
            .first::<DocumentRow>(conn.write().await.deref_mut())
            .await
            .map(Document::from)
            .optional()
            .map_err(|e| Self::Error::from(editoast_models::Error::from(e)))
    }
}
#[automatically_derived]
impl crate::prelude::Retrieve<(i64)> for Document {
    type Error = editoast_models::Error;
    #[tracing::instrument(
        name = "model:retrieve<Document>",
        skip_all,
        err,
        fields(query_id)
    )]
    async fn retrieve(
        conn: database::DbConnection,
        id_: (i64),
    ) -> std::result::Result<Option<Document>, Self::Error> {
        use diesel::prelude::*;
        use diesel_async::RunQueryDsl;
        use database::tables::osrd_infra_document::dsl;
        use std::ops::DerefMut;
        tracing::Span::current().record("query_id", tracing::field::debug(&id_));
        dsl::osrd_infra_document
            .filter(dsl::id.eq(id_))
            .select((dsl::id, dsl::content_type, dsl::data))
            .first::<DocumentRow>(conn.write().await.deref_mut())
            .await
            .map(Document::from)
            .optional()
            .map_err(|e| Self::Error::from(editoast_models::Error::from(e)))
    }
}
#[automatically_derived]
impl crate::prelude::Update<(String), Document> for DocumentChangeset {
    type Error = editoast_models::Error;
    #[tracing::instrument(
        name = "model:update<Document>",
        skip_all,
        err,
        fields(query_id)
    )]
    async fn update(
        self,
        conn: &mut database::DbConnection,
        content_type: (String),
    ) -> std::result::Result<Option<Document>, Self::Error> {
        use diesel::prelude::*;
        use diesel_async::RunQueryDsl;
        use std::ops::DerefMut;
        use database::tables::osrd_infra_document::dsl;
        tracing::Span::current()
            .record("query_id", tracing::field::debug(&content_type));
        diesel::update(
                dsl::osrd_infra_document.filter(dsl::content_type.eq(content_type)),
            )
            .set(&self)
            .returning((dsl::id, dsl::content_type, dsl::data))
            .get_result::<DocumentRow>(conn.write().await.deref_mut())
            .await
            .map(Into::into)
            .optional()
            .map_err(|e| Self::Error::from(editoast_models::Error::from(e)))
    }
}
#[automatically_derived]
impl crate::prelude::Update<(i64), Document> for DocumentChangeset {
    type Error = editoast_models::Error;
    #[tracing::instrument(
        name = "model:update<Document>",
        skip_all,
        err,
        fields(query_id)
    )]
    async fn update(
        self,
        conn: &mut database::DbConnection,
        id_: (i64),
    ) -> std::result::Result<Option<Document>, Self::Error> {
        use diesel::prelude::*;
        use diesel_async::RunQueryDsl;
        use std::ops::DerefMut;
        use database::tables::osrd_infra_document::dsl;
        tracing::Span::current().record("query_id", tracing::field::debug(&id_));
        diesel::update(dsl::osrd_infra_document.filter(dsl::id.eq(id_)))
            .set(&self)
            .returning((dsl::id, dsl::content_type, dsl::data))
            .get_result::<DocumentRow>(conn.write().await.deref_mut())
            .await
            .map(Into::into)
            .optional()
            .map_err(|e| Self::Error::from(editoast_models::Error::from(e)))
    }
}
#[automatically_derived]
impl crate::prelude::DeleteStatic<(String)> for Document {
    type Error = editoast_models::Error;
    #[tracing::instrument(
        name = "model:delete_static<Document>",
        skip_all,
        ret,
        err,
        fields(query_id)
    )]
    async fn delete_static(
        conn: &mut database::DbConnection,
        content_type: (String),
    ) -> std::result::Result<bool, Self::Error> {
        use diesel::prelude::*;
        use diesel_async::RunQueryDsl;
        use std::ops::DerefMut;
        use database::tables::osrd_infra_document::dsl;
        tracing::Span::current()
            .record("query_id", tracing::field::debug(&content_type));
        diesel::delete(
                dsl::osrd_infra_document.filter(dsl::content_type.eq(content_type)),
            )
            .execute(conn.write().await.deref_mut())
            .await
            .map(|n| n == 1)
            .map_err(|e| Self::Error::from(editoast_models::Error::from(e)))
    }
}
#[automatically_derived]
impl crate::prelude::DeleteStatic<(i64)> for Document {
    type Error = editoast_models::Error;
    #[tracing::instrument(
        name = "model:delete_static<Document>",
        skip_all,
        ret,
        err,
        fields(query_id)
    )]
    async fn delete_static(
        conn: &mut database::DbConnection,
        id_: (i64),
    ) -> std::result::Result<bool, Self::Error> {
        use diesel::prelude::*;
        use diesel_async::RunQueryDsl;
        use std::ops::DerefMut;
        use database::tables::osrd_infra_document::dsl;
        tracing::Span::current().record("query_id", tracing::field::debug(&id_));
        diesel::delete(dsl::osrd_infra_document.filter(dsl::id.eq(id_)))
            .execute(conn.write().await.deref_mut())
            .await
            .map(|n| n == 1)
            .map_err(|e| Self::Error::from(editoast_models::Error::from(e)))
    }
}
#[automatically_derived]
impl crate::prelude::Create<Document> for DocumentChangeset {
    type Error = editoast_models::Error;
    #[tracing::instrument(name = "model:create<Document>", skip_all, err)]
    async fn create(
        self,
        conn: &mut database::DbConnection,
    ) -> std::result::Result<Document, Self::Error> {
        use diesel_async::RunQueryDsl;
        use database::tables::osrd_infra_document::dsl;
        use std::ops::DerefMut;
        diesel::insert_into(database::tables::osrd_infra_document::table)
            .values(&self)
            .returning((dsl::id, dsl::content_type, dsl::data))
            .get_result::<DocumentRow>(conn.write().await.deref_mut())
            .await
            .map(Into::into)
            .map_err(|e| Self::Error::from(editoast_models::Error::from(e)))
    }
}
#[automatically_derived]
impl crate::prelude::Delete for Document {
    type Error = editoast_models::Error;
    #[tracing::instrument(
        name = "model:delete<Document>",
        skip_all,
        ret,
        err,
        fields(query_id = ?self.id_)
    )]
    async fn delete(
        &self,
        conn: &mut database::DbConnection,
    ) -> std::result::Result<bool, Self::Error> {
        use diesel::prelude::*;
        use diesel_async::RunQueryDsl;
        use database::tables::osrd_infra_document::dsl;
        use std::ops::DerefMut;
        let id = self.id_;
        diesel::delete(database::tables::osrd_infra_document::table.find(id))
            .execute(conn.write().await.deref_mut())
            .await
            .map(|n| n == 1)
            .map_err(|e| Self::Error::from(editoast_models::Error::from(e)))
    }
}
#[automatically_derived]
impl crate::prelude::List for Document {
    type Error = editoast_models::Error;
    #[tracing::instrument(
        name = "model:list<Document>",
        skip_all,
        err,
        fields(
            nb_filters = settings.filters.len(),
            nb_sorts = settings.sorts.len(),
            paginate_counting = settings.paginate_counting,
            limit,
            offset,
        )
    )]
    async fn list(
        conn: &mut database::DbConnection,
        settings: crate::prelude::SelectionSettings<Self>,
    ) -> std::result::Result<Vec<Self>, Self::Error> {
        use diesel::QueryDsl;
        use diesel_async::RunQueryDsl;
        use futures_util::stream::TryStreamExt;
        use database::tables::osrd_infra_document::dsl;
        use std::ops::DerefMut;
        let mut query = database::tables::osrd_infra_document::table.into_boxed();
        for filter_fun in settings.filters {
            let crate::prelude::FilterSetting(filter) = (*filter_fun)();
            query = query.filter(filter);
        }
        for sort_fun in settings.sorts {
            let crate::prelude::SortSetting(sort) = (*sort_fun)();
            query = query.order_by(sort);
        }
        if let Some(limit) = settings.limit {
            tracing::Span::current().record("limit", limit);
            query = query.limit(limit);
        }
        if let Some(offset) = settings.offset {
            tracing::Span::current().record("offset", offset);
            query = query.offset(offset);
        }
        query
            .select((dsl::id, dsl::content_type, dsl::data))
            .load_stream::<DocumentRow>(conn.write().await.deref_mut())
            .await
            .map_err(|e| Self::Error::from(editoast_models::Error::from(e)))?
            .map_ok(<Document as crate::prelude::Model>::from_row)
            .try_collect::<Vec<_>>()
            .await
            .map_err(|e| Self::Error::from(editoast_models::Error::from(e)))
    }
}
#[automatically_derived]
impl crate::prelude::Count for Document {
    type Error = editoast_models::Error;
    #[tracing::instrument(
        name = "model:count<Document>",
        skip_all,
        ret,
        err,
        fields(
            nb_filters = settings.filters.len(),
            paginate_counting = settings.paginate_counting,
            limit,
            offset,
        )
    )]
    async fn count(
        conn: &mut database::DbConnection,
        settings: crate::prelude::SelectionSettings<Self>,
    ) -> std::result::Result<u64, Self::Error> {
        use diesel::QueryDsl;
        use diesel_async::RunQueryDsl;
        use futures_util::stream::TryStreamExt;
        use std::ops::DerefMut;
        let mut query = database::tables::osrd_infra_document::table
            .select(diesel::dsl::count_star())
            .into_boxed();
        for filter_fun in settings.filters {
            let crate::prelude::FilterSetting(filter) = (*filter_fun)();
            query = query.filter(filter);
        }
        if settings.paginate_counting {
            if let Some(limit) = settings.limit {
                tracing::Span::current().record("limit", limit);
                query = query.limit(limit);
            }
            if let Some(offset) = settings.offset {
                tracing::Span::current().record("offset", offset);
                query = query.offset(offset);
            }
        }
        query
            .get_result::<i64>(conn.write().await.deref_mut())
            .await
            .map(|count| count as u64)
            .map_err(|e| Self::Error::from(editoast_models::Error::from(e)))
    }
}
#[automatically_derived]
impl crate::prelude::CreateBatch for Document {
    type Error = editoast_models::Error;
    #[tracing::instrument(name = "model:create_batch<Document>", skip_all, err)]
    async fn create_batch<
        I: std::iter::IntoIterator<Item = DocumentChangeset> + Send,
        C: Default + std::iter::Extend<Self> + Send + std::fmt::Debug,
    >(
        conn: &mut database::DbConnection,
        values: I,
    ) -> std::result::Result<C, Self::Error> {
        use crate::prelude::Model;
        use database::tables::osrd_infra_document::dsl;
        use std::ops::DerefMut;
        use diesel::prelude::*;
        use diesel_async::RunQueryDsl;
        use futures_util::stream::TryStreamExt;
        let values = values.into_iter().collect::<Vec<_>>();
        Ok({
            const LIBPQ_MAX_PARAMETERS: usize = 2_usize.pow(16) - 1;
            const ASYNC_SUBDIVISION: usize = 2_usize;
            const CHUNK_SIZE: usize = LIBPQ_MAX_PARAMETERS / ASYNC_SUBDIVISION / 2usize;
            let mut result = C::default();
            let chunks = values.chunks(CHUNK_SIZE.min(2048usize));
            for chunk in chunks {
                let chunk_result = {
                    diesel::insert_into(dsl::osrd_infra_document)
                        .values(chunk)
                        .returning((dsl::id, dsl::content_type, dsl::data))
                        .load_stream::<DocumentRow>(conn.write().await.deref_mut())
                        .await
                        .map_err(|e| Self::Error::from(editoast_models::Error::from(e)))?
                        .map_ok(<Document as Model>::from_row)
                        .try_collect::<Vec<_>>()
                        .await
                        .map_err(|e| Self::Error::from(editoast_models::Error::from(e)))?
                };
                result.extend(chunk_result);
            }
            result
        })
    }
}
#[automatically_derived]
impl crate::prelude::CreateBatchWithKey<(String)> for Document {
    type Error = editoast_models::Error;
    #[tracing::instrument(name = "model:create_batch_with_key<Document>", skip_all, err)]
    async fn create_batch_with_key<
        I: std::iter::IntoIterator<Item = DocumentChangeset> + Send,
        C: Default + std::iter::Extend<((String), Self)> + Send + std::fmt::Debug,
    >(
        conn: &mut database::DbConnection,
        values: I,
    ) -> std::result::Result<C, Self::Error> {
        use crate::prelude::Identifiable;
        use crate::prelude::Model;
        use std::ops::DerefMut;
        use database::tables::osrd_infra_document::dsl;
        use diesel::prelude::*;
        use diesel_async::RunQueryDsl;
        use futures_util::stream::TryStreamExt;
        let values = values.into_iter().collect::<Vec<_>>();
        Ok({
            const LIBPQ_MAX_PARAMETERS: usize = 2_usize.pow(16) - 1;
            const ASYNC_SUBDIVISION: usize = 2_usize;
            const CHUNK_SIZE: usize = LIBPQ_MAX_PARAMETERS / ASYNC_SUBDIVISION / 2usize;
            let mut result = C::default();
            let chunks = values.chunks(CHUNK_SIZE.min(2048usize));
            for chunk in chunks {
                let chunk_result = {
                    diesel::insert_into(dsl::osrd_infra_document)
                        .values(chunk)
                        .returning((dsl::id, dsl::content_type, dsl::data))
                        .load_stream::<DocumentRow>(conn.write().await.deref_mut())
                        .await
                        .map_err(|e| Self::Error::from(editoast_models::Error::from(e)))?
                        .map_ok(|row| {
                            let model = <Document as Model>::from_row(row);
                            (model.get_id(), model)
                        })
                        .try_collect::<Vec<_>>()
                        .await
                        .map_err(|e| Self::Error::from(editoast_models::Error::from(e)))?
                };
                result.extend(chunk_result);
            }
            result
        })
    }
}
#[automatically_derived]
impl crate::prelude::CreateBatchWithKey<(i64)> for Document {
    type Error = editoast_models::Error;
    #[tracing::instrument(name = "model:create_batch_with_key<Document>", skip_all, err)]
    async fn create_batch_with_key<
        I: std::iter::IntoIterator<Item = DocumentChangeset> + Send,
        C: Default + std::iter::Extend<((i64), Self)> + Send + std::fmt::Debug,
    >(
        conn: &mut database::DbConnection,
        values: I,
    ) -> std::result::Result<C, Self::Error> {
        use crate::prelude::Identifiable;
        use crate::prelude::Model;
        use std::ops::DerefMut;
        use database::tables::osrd_infra_document::dsl;
        use diesel::prelude::*;
        use diesel_async::RunQueryDsl;
        use futures_util::stream::TryStreamExt;
        let values = values.into_iter().collect::<Vec<_>>();
        Ok({
            const LIBPQ_MAX_PARAMETERS: usize = 2_usize.pow(16) - 1;
            const ASYNC_SUBDIVISION: usize = 2_usize;
            const CHUNK_SIZE: usize = LIBPQ_MAX_PARAMETERS / ASYNC_SUBDIVISION / 2usize;
            let mut result = C::default();
            let chunks = values.chunks(CHUNK_SIZE.min(2048usize));
            for chunk in chunks {
                let chunk_result = {
                    diesel::insert_into(dsl::osrd_infra_document)
                        .values(chunk)
                        .returning((dsl::id, dsl::content_type, dsl::data))
                        .load_stream::<DocumentRow>(conn.write().await.deref_mut())
                        .await
                        .map_err(|e| Self::Error::from(editoast_models::Error::from(e)))?
                        .map_ok(|row| {
                            let model = <Document as Model>::from_row(row);
                            (model.get_id(), model)
                        })
                        .try_collect::<Vec<_>>()
                        .await
                        .map_err(|e| Self::Error::from(editoast_models::Error::from(e)))?
                };
                result.extend(chunk_result);
            }
            result
        })
    }
}
#[automatically_derived]
impl crate::prelude::RetrieveBatchUnchecked<(String)> for Document {
    type Error = editoast_models::Error;
    #[tracing::instrument(
        name = "model:retrieve_batch_unchecked<Document>",
        skip_all,
        err,
        fields(query_id)
    )]
    async fn retrieve_batch_unchecked<
        I: std::iter::IntoIterator<Item = (String)> + Send,
        C: Default + std::iter::Extend<Document> + Send + std::fmt::Debug,
    >(conn: &mut database::DbConnection, ids: I) -> std::result::Result<C, Self::Error> {
        use crate::prelude::Model;
        use database::tables::osrd_infra_document::dsl;
        use diesel::prelude::*;
        use diesel_async::RunQueryDsl;
        use futures_util::stream::TryStreamExt;
        use std::ops::DerefMut;
        let ids = ids.into_iter().collect::<Vec<_>>();
        tracing::Span::current().record("query_ids", tracing::field::debug(&ids));
        Ok({
            const LIBPQ_MAX_PARAMETERS: usize = 2_usize.pow(16) - 1;
            const ASYNC_SUBDIVISION: usize = 2_usize;
            const CHUNK_SIZE: usize = LIBPQ_MAX_PARAMETERS / ASYNC_SUBDIVISION / 1usize;
            let mut result = C::default();
            let chunks = ids.chunks(CHUNK_SIZE.min(2048usize));
            for chunk in chunks {
                let chunk_result = {
                    let mut query = dsl::osrd_infra_document.into_boxed();
                    for content_type in chunk.into_iter() {
                        query = query.or_filter(dsl::content_type.eq(content_type));
                    }
                    query
                        .select((dsl::id, dsl::content_type, dsl::data))
                        .load_stream::<DocumentRow>(conn.write().await.deref_mut())
                        .await
                        .map_err(|e| Self::Error::from(editoast_models::Error::from(e)))?
                        .map_ok(<Document as Model>::from_row)
                        .try_collect::<Vec<_>>()
                        .await
                        .map_err(|e| Self::Error::from(editoast_models::Error::from(e)))?
                };
                result.extend(chunk_result);
            }
            result
        })
    }
    #[tracing::instrument(
        name = "model:retrieve_batch_with_key_unchecked<Document>",
        skip_all,
        err,
        fields(query_id)
    )]
    async fn retrieve_batch_with_key_unchecked<
        I: std::iter::IntoIterator<Item = (String)> + Send,
        C: Default + std::iter::Extend<((String), Document)> + Send + std::fmt::Debug,
    >(conn: &mut database::DbConnection, ids: I) -> std::result::Result<C, Self::Error> {
        use crate::prelude::Identifiable;
        use crate::prelude::Model;
        use database::tables::osrd_infra_document::dsl;
        use diesel::prelude::*;
        use diesel_async::RunQueryDsl;
        use futures_util::stream::TryStreamExt;
        use std::ops::DerefMut;
        let ids = ids.into_iter().collect::<Vec<_>>();
        tracing::Span::current().record("query_ids", tracing::field::debug(&ids));
        Ok({
            const LIBPQ_MAX_PARAMETERS: usize = 2_usize.pow(16) - 1;
            const ASYNC_SUBDIVISION: usize = 2_usize;
            const CHUNK_SIZE: usize = LIBPQ_MAX_PARAMETERS / ASYNC_SUBDIVISION / 1usize;
            let mut result = C::default();
            let chunks = ids.chunks(CHUNK_SIZE.min(2048usize));
            for chunk in chunks {
                let chunk_result = {
                    let mut query = dsl::osrd_infra_document.into_boxed();
                    for content_type in chunk.into_iter() {
                        query = query.or_filter(dsl::content_type.eq(content_type));
                    }
                    query
                        .select((dsl::id, dsl::content_type, dsl::data))
                        .load_stream::<DocumentRow>(conn.write().await.deref_mut())
                        .await
                        .map_err(|e| Self::Error::from(editoast_models::Error::from(e)))?
                        .map_ok(|row| {
                            let model = <Document as Model>::from_row(row);
                            (model.get_id(), model)
                        })
                        .try_collect::<Vec<_>>()
                        .await
                        .map_err(|e| Self::Error::from(editoast_models::Error::from(e)))?
                };
                result.extend(chunk_result);
            }
            result
        })
    }
}
#[automatically_derived]
impl crate::prelude::RetrieveBatchUnchecked<(i64)> for Document {
    type Error = editoast_models::Error;
    #[tracing::instrument(
        name = "model:retrieve_batch_unchecked<Document>",
        skip_all,
        err,
        fields(query_id)
    )]
    async fn retrieve_batch_unchecked<
        I: std::iter::IntoIterator<Item = (i64)> + Send,
        C: Default + std::iter::Extend<Document> + Send + std::fmt::Debug,
    >(conn: &mut database::DbConnection, ids: I) -> std::result::Result<C, Self::Error> {
        use crate::prelude::Model;
        use database::tables::osrd_infra_document::dsl;
        use diesel::prelude::*;
        use diesel_async::RunQueryDsl;
        use futures_util::stream::TryStreamExt;
        use std::ops::DerefMut;
        let ids = ids.into_iter().collect::<Vec<_>>();
        tracing::Span::current().record("query_ids", tracing::field::debug(&ids));
        Ok({
            const LIBPQ_MAX_PARAMETERS: usize = 2_usize.pow(16) - 1;
            const ASYNC_SUBDIVISION: usize = 2_usize;
            const CHUNK_SIZE: usize = LIBPQ_MAX_PARAMETERS / ASYNC_SUBDIVISION / 1usize;
            let mut result = C::default();
            let chunks = ids.chunks(CHUNK_SIZE.min(2048usize));
            for chunk in chunks {
                let chunk_result = {
                    let mut query = dsl::osrd_infra_document.into_boxed();
                    for id_ in chunk.into_iter() {
                        query = query.or_filter(dsl::id.eq(id_));
                    }
                    query
                        .select((dsl::id, dsl::content_type, dsl::data))
                        .load_stream::<DocumentRow>(conn.write().await.deref_mut())
                        .await
                        .map_err(|e| Self::Error::from(editoast_models::Error::from(e)))?
                        .map_ok(<Document as Model>::from_row)
                        .try_collect::<Vec<_>>()
                        .await
                        .map_err(|e| Self::Error::from(editoast_models::Error::from(e)))?
                };
                result.extend(chunk_result);
            }
            result
        })
    }
    #[tracing::instrument(
        name = "model:retrieve_batch_with_key_unchecked<Document>",
        skip_all,
        err,
        fields(query_id)
    )]
    async fn retrieve_batch_with_key_unchecked<
        I: std::iter::IntoIterator<Item = (i64)> + Send,
        C: Default + std::iter::Extend<((i64), Document)> + Send + std::fmt::Debug,
    >(conn: &mut database::DbConnection, ids: I) -> std::result::Result<C, Self::Error> {
        use crate::prelude::Identifiable;
        use crate::prelude::Model;
        use database::tables::osrd_infra_document::dsl;
        use diesel::prelude::*;
        use diesel_async::RunQueryDsl;
        use futures_util::stream::TryStreamExt;
        use std::ops::DerefMut;
        let ids = ids.into_iter().collect::<Vec<_>>();
        tracing::Span::current().record("query_ids", tracing::field::debug(&ids));
        Ok({
            const LIBPQ_MAX_PARAMETERS: usize = 2_usize.pow(16) - 1;
            const ASYNC_SUBDIVISION: usize = 2_usize;
            const CHUNK_SIZE: usize = LIBPQ_MAX_PARAMETERS / ASYNC_SUBDIVISION / 1usize;
            let mut result = C::default();
            let chunks = ids.chunks(CHUNK_SIZE.min(2048usize));
            for chunk in chunks {
                let chunk_result = {
                    let mut query = dsl::osrd_infra_document.into_boxed();
                    for id_ in chunk.into_iter() {
                        query = query.or_filter(dsl::id.eq(id_));
                    }
                    query
                        .select((dsl::id, dsl::content_type, dsl::data))
                        .load_stream::<DocumentRow>(conn.write().await.deref_mut())
                        .await
                        .map_err(|e| Self::Error::from(editoast_models::Error::from(e)))?
                        .map_ok(|row| {
                            let model = <Document as Model>::from_row(row);
                            (model.get_id(), model)
                        })
                        .try_collect::<Vec<_>>()
                        .await
                        .map_err(|e| Self::Error::from(editoast_models::Error::from(e)))?
                };
                result.extend(chunk_result);
            }
            result
        })
    }
}
#[automatically_derived]
impl crate::prelude::UpdateBatchUnchecked<Document, (String)> for DocumentChangeset {
    type Error = editoast_models::Error;
    #[tracing::instrument(
        name = "model:update_batch_unchecked<Document>",
        skip_all,
        err,
        fields(query_ids)
    )]
    async fn update_batch_unchecked<
        I: std::iter::IntoIterator<Item = (String)> + Send,
        C: Default + std::iter::Extend<Document> + Send + std::fmt::Debug,
    >(
        self,
        conn: &mut database::DbConnection,
        ids: I,
    ) -> crate::error::Result<C, Self::Error> {
        use crate::prelude::Model;
        use database::tables::osrd_infra_document::dsl;
        use diesel::prelude::*;
        use diesel_async::RunQueryDsl;
        use futures_util::stream::TryStreamExt as _;
        use futures_util::TryFutureExt as _;
        use std::ops::DerefMut;
        let ids = ids.into_iter().collect::<Vec<_>>();
        tracing::Span::current().record("query_ids", tracing::field::debug(&ids));
        Ok({
            const LIBPQ_MAX_PARAMETERS: usize = 2_usize.pow(16) - 1;
            const ASYNC_SUBDIVISION: usize = 2_usize;
            const CHUNK_SIZE: usize = LIBPQ_MAX_PARAMETERS / ASYNC_SUBDIVISION / 1usize;
            let mut result = C::default();
            let chunks = ids.chunks(CHUNK_SIZE.min(2048usize));
            for chunk in chunks {
                let chunk_result = {
                    let mut query = dsl::osrd_infra_document
                        .select(dsl::id)
                        .into_boxed();
                    for content_type in chunk.into_iter() {
                        query = query.or_filter(dsl::content_type.eq(content_type));
                    }
                    diesel::update(dsl::osrd_infra_document)
                        .filter(dsl::id.eq_any(query))
                        .set(&self)
                        .returning((dsl::id, dsl::content_type, dsl::data))
                        .load_stream::<DocumentRow>(conn.write().await.deref_mut())
                        .await
                        .map_err(|e| Self::Error::from(editoast_models::Error::from(e)))?
                        .map_ok(<Document as Model>::from_row)
                        .try_collect::<Vec<_>>()
                        .await
                        .map_err(|e| Self::Error::from(editoast_models::Error::from(e)))?
                };
                result.extend(chunk_result);
            }
            result
        })
    }
    #[tracing::instrument(
        name = "model:update_batch_unchecked<Document>",
        skip_all,
        err,
        fields(query_ids)
    )]
    async fn update_batch_with_key_unchecked<
        I: std::iter::IntoIterator<Item = (String)> + Send,
        C: Default + std::iter::Extend<((String), Document)> + Send,
    >(
        self,
        conn: &mut database::DbConnection,
        ids: I,
    ) -> crate::error::Result<C, Self::Error> {
        use crate::prelude::Identifiable;
        use crate::prelude::Model;
        use database::tables::osrd_infra_document::dsl;
        use std::ops::DerefMut;
        use diesel::prelude::*;
        use diesel_async::RunQueryDsl;
        use futures_util::stream::TryStreamExt as _;
        use futures_util::TryFutureExt as _;
        let ids = ids.into_iter().collect::<Vec<_>>();
        tracing::Span::current().record("query_ids", tracing::field::debug(&ids));
        Ok({
            const LIBPQ_MAX_PARAMETERS: usize = 2_usize.pow(16) - 1;
            const ASYNC_SUBDIVISION: usize = 2_usize;
            const CHUNK_SIZE: usize = LIBPQ_MAX_PARAMETERS / ASYNC_SUBDIVISION / 1usize;
            let mut result = C::default();
            let chunks = ids.chunks(CHUNK_SIZE.min(2048usize));
            for chunk in chunks {
                let chunk_result = {
                    let mut query = dsl::osrd_infra_document
                        .select(dsl::id)
                        .into_boxed();
                    for content_type in chunk.into_iter() {
                        query = query.or_filter(dsl::content_type.eq(content_type));
                    }
                    diesel::update(dsl::osrd_infra_document)
                        .filter(dsl::id.eq_any(query))
                        .set(&self)
                        .returning((dsl::id, dsl::content_type, dsl::data))
                        .load_stream::<DocumentRow>(conn.write().await.deref_mut())
                        .await
                        .map_err(|e| Self::Error::from(editoast_models::Error::from(e)))?
                        .map_ok(|row| {
                            let model = <Document as Model>::from_row(row);
                            (model.get_id(), model)
                        })
                        .try_collect::<Vec<_>>()
                        .await
                        .map_err(|e| Self::Error::from(editoast_models::Error::from(e)))?
                };
                result.extend(chunk_result);
            }
            result
        })
    }
}
#[automatically_derived]
impl crate::prelude::UpdateBatchUnchecked<Document, (i64)> for DocumentChangeset {
    type Error = editoast_models::Error;
    #[tracing::instrument(
        name = "model:update_batch_unchecked<Document>",
        skip_all,
        err,
        fields(query_ids)
    )]
    async fn update_batch_unchecked<
        I: std::iter::IntoIterator<Item = (i64)> + Send,
        C: Default + std::iter::Extend<Document> + Send + std::fmt::Debug,
    >(
        self,
        conn: &mut database::DbConnection,
        ids: I,
    ) -> crate::error::Result<C, Self::Error> {
        use crate::prelude::Model;
        use database::tables::osrd_infra_document::dsl;
        use diesel::prelude::*;
        use diesel_async::RunQueryDsl;
        use futures_util::stream::TryStreamExt as _;
        use futures_util::TryFutureExt as _;
        use std::ops::DerefMut;
        let ids = ids.into_iter().collect::<Vec<_>>();
        tracing::Span::current().record("query_ids", tracing::field::debug(&ids));
        Ok({
            const LIBPQ_MAX_PARAMETERS: usize = 2_usize.pow(16) - 1;
            const ASYNC_SUBDIVISION: usize = 2_usize;
            const CHUNK_SIZE: usize = LIBPQ_MAX_PARAMETERS / ASYNC_SUBDIVISION / 1usize;
            let mut result = C::default();
            let chunks = ids.chunks(CHUNK_SIZE.min(2048usize));
            for chunk in chunks {
                let chunk_result = {
                    let mut query = dsl::osrd_infra_document
                        .select(dsl::id)
                        .into_boxed();
                    for id_ in chunk.into_iter() {
                        query = query.or_filter(dsl::id.eq(id_));
                    }
                    diesel::update(dsl::osrd_infra_document)
                        .filter(dsl::id.eq_any(query))
                        .set(&self)
                        .returning((dsl::id, dsl::content_type, dsl::data))
                        .load_stream::<DocumentRow>(conn.write().await.deref_mut())
                        .await
                        .map_err(|e| Self::Error::from(editoast_models::Error::from(e)))?
                        .map_ok(<Document as Model>::from_row)
                        .try_collect::<Vec<_>>()
                        .await
                        .map_err(|e| Self::Error::from(editoast_models::Error::from(e)))?
                };
                result.extend(chunk_result);
            }
            result
        })
    }
    #[tracing::instrument(
        name = "model:update_batch_unchecked<Document>",
        skip_all,
        err,
        fields(query_ids)
    )]
    async fn update_batch_with_key_unchecked<
        I: std::iter::IntoIterator<Item = (i64)> + Send,
        C: Default + std::iter::Extend<((i64), Document)> + Send,
    >(
        self,
        conn: &mut database::DbConnection,
        ids: I,
    ) -> crate::error::Result<C, Self::Error> {
        use crate::prelude::Identifiable;
        use crate::prelude::Model;
        use database::tables::osrd_infra_document::dsl;
        use std::ops::DerefMut;
        use diesel::prelude::*;
        use diesel_async::RunQueryDsl;
        use futures_util::stream::TryStreamExt as _;
        use futures_util::TryFutureExt as _;
        let ids = ids.into_iter().collect::<Vec<_>>();
        tracing::Span::current().record("query_ids", tracing::field::debug(&ids));
        Ok({
            const LIBPQ_MAX_PARAMETERS: usize = 2_usize.pow(16) - 1;
            const ASYNC_SUBDIVISION: usize = 2_usize;
            const CHUNK_SIZE: usize = LIBPQ_MAX_PARAMETERS / ASYNC_SUBDIVISION / 1usize;
            let mut result = C::default();
            let chunks = ids.chunks(CHUNK_SIZE.min(2048usize));
            for chunk in chunks {
                let chunk_result = {
                    let mut query = dsl::osrd_infra_document
                        .select(dsl::id)
                        .into_boxed();
                    for id_ in chunk.into_iter() {
                        query = query.or_filter(dsl::id.eq(id_));
                    }
                    diesel::update(dsl::osrd_infra_document)
                        .filter(dsl::id.eq_any(query))
                        .set(&self)
                        .returning((dsl::id, dsl::content_type, dsl::data))
                        .load_stream::<DocumentRow>(conn.write().await.deref_mut())
                        .await
                        .map_err(|e| Self::Error::from(editoast_models::Error::from(e)))?
                        .map_ok(|row| {
                            let model = <Document as Model>::from_row(row);
                            (model.get_id(), model)
                        })
                        .try_collect::<Vec<_>>()
                        .await
                        .map_err(|e| Self::Error::from(editoast_models::Error::from(e)))?
                };
                result.extend(chunk_result);
            }
            result
        })
    }
}
#[automatically_derived]
impl crate::prelude::DeleteBatch<(String)> for Document {
    type Error = editoast_models::Error;
    #[tracing::instrument(
        name = "model:delete_batch<Document>",
        skip_all,
        ret,
        err,
        fields(query_ids)
    )]
    async fn delete_batch<I: std::iter::IntoIterator<Item = (String)> + Send>(
        conn: &mut database::DbConnection,
        ids: I,
    ) -> std::result::Result<usize, Self::Error> {
        use database::tables::osrd_infra_document::dsl;
        use diesel::prelude::*;
        use diesel_async::RunQueryDsl;
        use std::ops::DerefMut;
        let ids = ids.into_iter().collect::<Vec<_>>();
        tracing::Span::current().record("query_ids", tracing::field::debug(&ids));
        let counts = {
            const LIBPQ_MAX_PARAMETERS: usize = 2_usize.pow(16) - 1;
            const ASYNC_SUBDIVISION: usize = 2_usize;
            const CHUNK_SIZE: usize = LIBPQ_MAX_PARAMETERS / ASYNC_SUBDIVISION / 1usize;
            let mut result = Vec::new();
            let chunks = ids.chunks(CHUNK_SIZE.min(2048usize));
            for chunk in chunks {
                let chunk_result = {
                    let mut query = diesel::delete(dsl::osrd_infra_document)
                        .into_boxed();
                    for content_type in chunk.into_iter() {
                        query = query.or_filter(dsl::content_type.eq(content_type));
                    }
                    query
                        .execute(conn.write().await.deref_mut())
                        .await
                        .map_err(|e| Self::Error::from(editoast_models::Error::from(e)))?
                };
                result.push(chunk_result);
            }
            result
        };
        Ok(counts.into_iter().sum())
    }
}
#[automatically_derived]
impl crate::prelude::DeleteBatch<(i64)> for Document {
    type Error = editoast_models::Error;
    #[tracing::instrument(
        name = "model:delete_batch<Document>",
        skip_all,
        ret,
        err,
        fields(query_ids)
    )]
    async fn delete_batch<I: std::iter::IntoIterator<Item = (i64)> + Send>(
        conn: &mut database::DbConnection,
        ids: I,
    ) -> std::result::Result<usize, Self::Error> {
        use database::tables::osrd_infra_document::dsl;
        use diesel::prelude::*;
        use diesel_async::RunQueryDsl;
        use std::ops::DerefMut;
        let ids = ids.into_iter().collect::<Vec<_>>();
        tracing::Span::current().record("query_ids", tracing::field::debug(&ids));
        let counts = {
            const LIBPQ_MAX_PARAMETERS: usize = 2_usize.pow(16) - 1;
            const ASYNC_SUBDIVISION: usize = 2_usize;
            const CHUNK_SIZE: usize = LIBPQ_MAX_PARAMETERS / ASYNC_SUBDIVISION / 1usize;
            let mut result = Vec::new();
            let chunks = ids.chunks(CHUNK_SIZE.min(2048usize));
            for chunk in chunks {
                let chunk_result = {
                    let mut query = diesel::delete(dsl::osrd_infra_document)
                        .into_boxed();
                    for id_ in chunk.into_iter() {
                        query = query.or_filter(dsl::id.eq(id_));
                    }
                    query
                        .execute(conn.write().await.deref_mut())
                        .await
                        .map_err(|e| Self::Error::from(editoast_models::Error::from(e)))?
                };
                result.push(chunk_result);
            }
            result
        };
        Ok(counts.into_iter().sum())
    }
}
