---
source: editoast_derive/src/model.rs
---
// Source
// -----------------------------------------------------------------------------

#[derive(Clone, Model)]
#[model(table = database::tables::timetable)]
#[model(gen(ops = crd, batch_ops = rd, list))]
struct Timetable {
    id: i64,
}

// Macro expansion
// -----------------------------------------------------------------------------

#[automatically_derived]
impl crate::prelude::Model for Timetable {
    type Row = TimetableRow;
    type Changeset = TimetableChangeset;
    type Table = database::tables::timetable::table;
}
#[doc(hidden)]
struct _TimetableField<M, T, Column>(core::marker::PhantomData<(M, T, Column)>);
impl Timetable {
    pub const ID: _TimetableField<Timetable, i64, database::tables::timetable::id> = _TimetableField(
        core::marker::PhantomData,
    );
}
impl _TimetableField<Timetable, i64, database::tables::timetable::id> {
    pub fn eq(&self, value: i64) -> crate::prelude::FilterSetting<Timetable> {
        use diesel::ExpressionMethods;
        crate::prelude::FilterSetting::new(database::tables::timetable::id.eq(value))
    }
    pub fn eq_any(&self, values: Vec<i64>) -> crate::prelude::FilterSetting<Timetable> {
        use diesel::ExpressionMethods;
        crate::prelude::FilterSetting::new(
            database::tables::timetable::id.eq_any(values),
        )
    }
    pub fn asc(&self) -> crate::prelude::SortSetting<Timetable> {
        use diesel::ExpressionMethods;
        crate::prelude::SortSetting(Box::new(database::tables::timetable::id.asc()))
    }
    pub fn desc(&self) -> crate::prelude::SortSetting<Timetable> {
        use diesel::ExpressionMethods;
        crate::prelude::SortSetting(Box::new(database::tables::timetable::id.desc()))
    }
}
#[derive(diesel::Queryable)]
#[diesel(table_name = database::tables::timetable)]
struct TimetableRow {
    #[diesel(column_name = "id")]
    id: i64,
}
#[derive(Debug, Default)]
struct TimetableChangeset;
#[automatically_derived]
impl crate::prelude::Identifiable<(i64)> for Timetable {
    fn get_id(&self) -> (i64) {
        (self.id.clone())
    }
}
#[automatically_derived]
impl crate::prelude::PreferredId<(i64)> for Timetable {}
#[automatically_derived]
impl From<TimetableRow> for Timetable {
    fn from(row: TimetableRow) -> Self {
        Self { id: row.id }
    }
}
#[automatically_derived]
impl From<Timetable> for TimetableChangeset {
    fn from(model: Timetable) -> Self {
        Self {}
    }
}
impl TimetableChangeset {}
#[automatically_derived]
impl crate::prelude::Exists<(i64)> for Timetable {
    type Error = editoast_models::Error;
    #[tracing::instrument(
        name = "model:exists<Timetable>",
        skip_all,
        ret,
        err,
        fields(query_id)
    )]
    async fn exists(
        conn: &mut database::DbConnection,
        id: (i64),
    ) -> std::result::Result<bool, Self::Error> {
        use diesel::prelude::*;
        use diesel_async::RunQueryDsl;
        use std::ops::DerefMut;
        use database::tables::timetable::dsl;
        tracing::Span::current().record("query_id", tracing::field::debug(&id));
        diesel::select(diesel::dsl::exists(dsl::timetable.filter(dsl::id.eq(id))))
            .get_result(conn.write().await.deref_mut())
            .await
            .map_err(|e| Self::Error::from(editoast_models::Error::from(e)))
    }
}
#[automatically_derived]
impl crate::prelude::Retrieve<(i64)> for Timetable {
    type Error = editoast_models::Error;
    #[tracing::instrument(
        name = "model:retrieve<Timetable>",
        skip_all,
        err,
        fields(query_id)
    )]
    async fn retrieve(
        conn: database::DbConnection,
        id: (i64),
    ) -> std::result::Result<Option<Timetable>, Self::Error> {
        use diesel::prelude::*;
        use diesel_async::RunQueryDsl;
        use database::tables::timetable::dsl;
        use std::ops::DerefMut;
        tracing::Span::current().record("query_id", tracing::field::debug(&id));
        dsl::timetable
            .filter(dsl::id.eq(id))
            .select((dsl::id,))
            .first::<TimetableRow>(conn.write().await.deref_mut())
            .await
            .map(Timetable::from)
            .optional()
            .map_err(|e| Self::Error::from(editoast_models::Error::from(e)))
    }
}
#[automatically_derived]
impl crate::prelude::DeleteStatic<(i64)> for Timetable {
    type Error = editoast_models::Error;
    #[tracing::instrument(
        name = "model:delete_static<Timetable>",
        skip_all,
        ret,
        err,
        fields(query_id)
    )]
    async fn delete_static(
        conn: &mut database::DbConnection,
        id: (i64),
    ) -> std::result::Result<bool, Self::Error> {
        use diesel::prelude::*;
        use diesel_async::RunQueryDsl;
        use std::ops::DerefMut;
        use database::tables::timetable::dsl;
        tracing::Span::current().record("query_id", tracing::field::debug(&id));
        diesel::delete(dsl::timetable.filter(dsl::id.eq(id)))
            .execute(conn.write().await.deref_mut())
            .await
            .map(|n| n == 1)
            .map_err(|e| Self::Error::from(editoast_models::Error::from(e)))
    }
}
#[automatically_derived]
impl crate::prelude::Create<Timetable> for TimetableChangeset {
    type Error = editoast_models::Error;
    #[tracing::instrument(name = "model:create<Timetable>", skip_all, err)]
    async fn create(
        self,
        conn: &mut database::DbConnection,
    ) -> std::result::Result<Timetable, Self::Error> {
        use diesel_async::RunQueryDsl;
        use database::tables::timetable::dsl;
        use std::ops::DerefMut;
        diesel::insert_into(database::tables::timetable::table)
            .default_values()
            .returning((dsl::id,))
            .get_result::<TimetableRow>(conn.write().await.deref_mut())
            .await
            .map(Into::into)
            .map_err(|e| Self::Error::from(editoast_models::Error::from(e)))
    }
}
#[automatically_derived]
impl crate::prelude::Delete for Timetable {
    type Error = editoast_models::Error;
    #[tracing::instrument(
        name = "model:delete<Timetable>",
        skip_all,
        ret,
        err,
        fields(query_id = ?self.id)
    )]
    async fn delete(
        &self,
        conn: &mut database::DbConnection,
    ) -> std::result::Result<bool, Self::Error> {
        use diesel::prelude::*;
        use diesel_async::RunQueryDsl;
        use database::tables::timetable::dsl;
        use std::ops::DerefMut;
        let id = self.id;
        diesel::delete(database::tables::timetable::table.find(id))
            .execute(conn.write().await.deref_mut())
            .await
            .map(|n| n == 1)
            .map_err(|e| Self::Error::from(editoast_models::Error::from(e)))
    }
}
#[automatically_derived]
impl crate::prelude::List for Timetable {
    type Error = editoast_models::Error;
    #[tracing::instrument(
        name = "model:list<Timetable>",
        skip_all,
        err,
        fields(
            nb_filters = settings.filters.len(),
            nb_sorts = settings.sorts.len(),
            paginate_counting = settings.paginate_counting,
            limit,
            offset,
        )
    )]
    async fn list(
        conn: &mut database::DbConnection,
        settings: crate::prelude::SelectionSettings<Self>,
    ) -> std::result::Result<Vec<Self>, Self::Error> {
        use diesel::QueryDsl;
        use diesel_async::RunQueryDsl;
        use futures_util::stream::TryStreamExt;
        use database::tables::timetable::dsl;
        use std::ops::DerefMut;
        let mut query = database::tables::timetable::table.into_boxed();
        for filter_fun in settings.filters {
            let crate::prelude::FilterSetting(filter) = (*filter_fun)();
            query = query.filter(filter);
        }
        for sort_fun in settings.sorts {
            let crate::prelude::SortSetting(sort) = (*sort_fun)();
            query = query.order_by(sort);
        }
        if let Some(limit) = settings.limit {
            tracing::Span::current().record("limit", limit);
            query = query.limit(limit);
        }
        if let Some(offset) = settings.offset {
            tracing::Span::current().record("offset", offset);
            query = query.offset(offset);
        }
        query
            .select((dsl::id,))
            .load_stream::<TimetableRow>(conn.write().await.deref_mut())
            .await
            .map_err(|e| Self::Error::from(editoast_models::Error::from(e)))?
            .map_ok(<Timetable as crate::prelude::Model>::from_row)
            .try_collect::<Vec<_>>()
            .await
            .map_err(|e| Self::Error::from(editoast_models::Error::from(e)))
    }
}
#[automatically_derived]
impl crate::prelude::Count for Timetable {
    type Error = editoast_models::Error;
    #[tracing::instrument(
        name = "model:count<Timetable>",
        skip_all,
        ret,
        err,
        fields(
            nb_filters = settings.filters.len(),
            paginate_counting = settings.paginate_counting,
            limit,
            offset,
        )
    )]
    async fn count(
        conn: &mut database::DbConnection,
        settings: crate::prelude::SelectionSettings<Self>,
    ) -> std::result::Result<u64, Self::Error> {
        use diesel::QueryDsl;
        use diesel_async::RunQueryDsl;
        use futures_util::stream::TryStreamExt;
        use std::ops::DerefMut;
        let mut query = database::tables::timetable::table
            .select(diesel::dsl::count_star())
            .into_boxed();
        for filter_fun in settings.filters {
            let crate::prelude::FilterSetting(filter) = (*filter_fun)();
            query = query.filter(filter);
        }
        if settings.paginate_counting {
            if let Some(limit) = settings.limit {
                tracing::Span::current().record("limit", limit);
                query = query.limit(limit);
            }
            if let Some(offset) = settings.offset {
                tracing::Span::current().record("offset", offset);
                query = query.offset(offset);
            }
        }
        query
            .get_result::<i64>(conn.write().await.deref_mut())
            .await
            .map(|count| count as u64)
            .map_err(|e| Self::Error::from(editoast_models::Error::from(e)))
    }
}
#[automatically_derived]
impl crate::prelude::RetrieveBatchUnchecked<(i64)> for Timetable {
    type Error = editoast_models::Error;
    #[tracing::instrument(
        name = "model:retrieve_batch_unchecked<Timetable>",
        skip_all,
        err,
        fields(query_id)
    )]
    async fn retrieve_batch_unchecked<
        I: std::iter::IntoIterator<Item = (i64)> + Send,
        C: Default + std::iter::Extend<Timetable> + Send + std::fmt::Debug,
    >(conn: &mut database::DbConnection, ids: I) -> std::result::Result<C, Self::Error> {
        use crate::prelude::Model;
        use database::tables::timetable::dsl;
        use diesel::prelude::*;
        use diesel_async::RunQueryDsl;
        use futures_util::stream::TryStreamExt;
        use std::ops::DerefMut;
        let ids = ids.into_iter().collect::<Vec<_>>();
        tracing::Span::current().record("query_ids", tracing::field::debug(&ids));
        Ok({
            const LIBPQ_MAX_PARAMETERS: usize = 2_usize.pow(16) - 1;
            const ASYNC_SUBDIVISION: usize = 2_usize;
            const CHUNK_SIZE: usize = LIBPQ_MAX_PARAMETERS / ASYNC_SUBDIVISION / 1usize;
            let mut result = C::default();
            let chunks = ids.chunks(CHUNK_SIZE.min(2048usize));
            for chunk in chunks {
                let chunk_result = {
                    let mut query = dsl::timetable.into_boxed();
                    for id in chunk.into_iter() {
                        query = query.or_filter(dsl::id.eq(id));
                    }
                    query
                        .select((dsl::id,))
                        .load_stream::<TimetableRow>(conn.write().await.deref_mut())
                        .await
                        .map_err(|e| Self::Error::from(editoast_models::Error::from(e)))?
                        .map_ok(<Timetable as Model>::from_row)
                        .try_collect::<Vec<_>>()
                        .await
                        .map_err(|e| Self::Error::from(editoast_models::Error::from(e)))?
                };
                result.extend(chunk_result);
            }
            result
        })
    }
    #[tracing::instrument(
        name = "model:retrieve_batch_with_key_unchecked<Timetable>",
        skip_all,
        err,
        fields(query_id)
    )]
    async fn retrieve_batch_with_key_unchecked<
        I: std::iter::IntoIterator<Item = (i64)> + Send,
        C: Default + std::iter::Extend<((i64), Timetable)> + Send + std::fmt::Debug,
    >(conn: &mut database::DbConnection, ids: I) -> std::result::Result<C, Self::Error> {
        use crate::prelude::Identifiable;
        use crate::prelude::Model;
        use database::tables::timetable::dsl;
        use diesel::prelude::*;
        use diesel_async::RunQueryDsl;
        use futures_util::stream::TryStreamExt;
        use std::ops::DerefMut;
        let ids = ids.into_iter().collect::<Vec<_>>();
        tracing::Span::current().record("query_ids", tracing::field::debug(&ids));
        Ok({
            const LIBPQ_MAX_PARAMETERS: usize = 2_usize.pow(16) - 1;
            const ASYNC_SUBDIVISION: usize = 2_usize;
            const CHUNK_SIZE: usize = LIBPQ_MAX_PARAMETERS / ASYNC_SUBDIVISION / 1usize;
            let mut result = C::default();
            let chunks = ids.chunks(CHUNK_SIZE.min(2048usize));
            for chunk in chunks {
                let chunk_result = {
                    let mut query = dsl::timetable.into_boxed();
                    for id in chunk.into_iter() {
                        query = query.or_filter(dsl::id.eq(id));
                    }
                    query
                        .select((dsl::id,))
                        .load_stream::<TimetableRow>(conn.write().await.deref_mut())
                        .await
                        .map_err(|e| Self::Error::from(editoast_models::Error::from(e)))?
                        .map_ok(|row| {
                            let model = <Timetable as Model>::from_row(row);
                            (model.get_id(), model)
                        })
                        .try_collect::<Vec<_>>()
                        .await
                        .map_err(|e| Self::Error::from(editoast_models::Error::from(e)))?
                };
                result.extend(chunk_result);
            }
            result
        })
    }
}
#[automatically_derived]
impl crate::prelude::DeleteBatch<(i64)> for Timetable {
    type Error = editoast_models::Error;
    #[tracing::instrument(
        name = "model:delete_batch<Timetable>",
        skip_all,
        ret,
        err,
        fields(query_ids)
    )]
    async fn delete_batch<I: std::iter::IntoIterator<Item = (i64)> + Send>(
        conn: &mut database::DbConnection,
        ids: I,
    ) -> std::result::Result<usize, Self::Error> {
        use database::tables::timetable::dsl;
        use diesel::prelude::*;
        use diesel_async::RunQueryDsl;
        use std::ops::DerefMut;
        let ids = ids.into_iter().collect::<Vec<_>>();
        tracing::Span::current().record("query_ids", tracing::field::debug(&ids));
        let counts = {
            const LIBPQ_MAX_PARAMETERS: usize = 2_usize.pow(16) - 1;
            const ASYNC_SUBDIVISION: usize = 2_usize;
            const CHUNK_SIZE: usize = LIBPQ_MAX_PARAMETERS / ASYNC_SUBDIVISION / 1usize;
            let mut result = Vec::new();
            let chunks = ids.chunks(CHUNK_SIZE.min(2048usize));
            for chunk in chunks {
                let chunk_result = {
                    let mut query = diesel::delete(dsl::timetable).into_boxed();
                    for id in chunk.into_iter() {
                        query = query.or_filter(dsl::id.eq(id));
                    }
                    query
                        .execute(conn.write().await.deref_mut())
                        .await
                        .map_err(|e| Self::Error::from(editoast_models::Error::from(e)))?
                };
                result.push(chunk_result);
            }
            result
        };
        Ok(counts.into_iter().sum())
    }
}
