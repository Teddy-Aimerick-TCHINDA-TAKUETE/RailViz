use std::fmt::Debug;

use database::DbConnection;

use super::Model;

/// Describes how a [Model] can be retrieved from the database
///
/// You can implement this type manually but its recommended to use the `Model`
/// derive macro instead.
pub trait Retrieve<K>: Model
where
    K: Send,
    Self: Send,
{
    type Error: std::error::Error + From<crate::Error> + Send;

    /// Retrieves the row #`id` and deserializes it as a model instance
    async fn retrieve(conn: DbConnection, id: K) -> Result<Option<Self>, Self::Error>;

    /// Just like [Retrieve::retrieve] but returns `Err(fail())` if the row was not found
    async fn retrieve_or_fail<E, F>(conn: DbConnection, id: K, fail: F) -> Result<Self, E>
    where
        E: From<Self::Error>,
        F: FnOnce() -> E + Send,
    {
        match Self::retrieve(conn, id).await {
            Ok(Some(obj)) => Ok(obj),
            Ok(None) => Err(fail()),
            Err(e) => Err(E::from(e)),
        }
    }
}

/// Describes how to check for the existence of a [Model] in the database
///
/// You can implement this type manually but its recommended to use the `Model`
/// derive macro instead.
pub trait Exists<K>: Model
where
    K: Send,
    Self: Send,
{
    type Error: std::error::Error + From<crate::Error> + Send;

    /// Returns whether the row #`id` exists in the database
    async fn exists(conn: &mut DbConnection, id: K) -> Result<bool, Self::Error>;

    /// Just like [Exists::exists] but returns `Err(fail())` if the row doesn't exist
    async fn exists_or_fail<E, F>(conn: &mut DbConnection, id: K, fail: F) -> Result<(), E>
    where
        E: From<Self::Error>,
        F: FnOnce() -> E + Send,
    {
        match Self::exists(conn, id).await {
            Ok(true) => Ok(()),
            Ok(false) => Err(fail()),
            Err(e) => Err(E::from(e)),
        }
    }
}

/// Unchecked batch retrieval of a [Model] from the database
///
/// Any [Model] that implement this trait also implement [RetrieveBatch].
/// Unless you know what you're doing, you should use [RetrieveBatch] instead.
///
/// You can implement this type manually but its recommended to use the `Model`
/// derive macro instead.
pub trait RetrieveBatchUnchecked<K>: Model
where
    K: Send + Debug,
    Self: Send,
{
    type Error: std::error::Error + From<crate::Error> + Send;

    /// Retrieves a batch of rows from the database given an iterator of keys
    ///
    /// Returns a collection of the retrieved rows. That collection can contain
    /// fewer items than the number of provided keys if some rows were not found.
    /// Use [RetrieveBatch::retrieve_batch] or [RetrieveBatch::retrieve_batch_or_fail]
    /// if you want to fail if some rows were not found.
    /// Unless you know what you're doing, you should use these functions instead.
    async fn retrieve_batch_unchecked<
        I: IntoIterator<Item = K> + Send,
        C: Default + std::iter::Extend<Self> + Send + Debug,
    >(
        conn: &mut DbConnection,
        ids: I,
    ) -> Result<C, Self::Error>;

    /// Just like [RetrieveBatchUnchecked::retrieve_batch_unchecked] but the returned models are paired with their key
    ///
    /// Returns a collection of the retrieved rows. That collection can contain
    /// fewer items than the number of provided keys if some rows were not found.
    /// Use [RetrieveBatch::retrieve_batch_with_key] or [RetrieveBatch::retrieve_batch_with_key_or_fail]
    /// if you want to fail if some rows were not found.
    /// Unless you know what you're doing, you should use these functions instead.
    async fn retrieve_batch_with_key_unchecked<
        I: IntoIterator<Item = K> + Send,
        C: Default + std::iter::Extend<(K, Self)> + Send + Debug,
    >(
        conn: &mut DbConnection,
        ids: I,
    ) -> Result<C, Self::Error>;
}

/// Describes how a [Model] can be retrieved from the database given a batch of keys
///
/// This trait is automatically implemented for all models that implement
/// [RetrieveBatchUnchecked]. [RetrieveBatchUnchecked] is a lower-level trait
/// which implementation is automatically generated by the `Model` derive macro.
///
/// 99% of the time you should use this trait instead of [RetrieveBatchUnchecked].
/// This won't be possible however if the model's key is not `Eq` or `Hash`.
pub trait RetrieveBatch<K>: RetrieveBatchUnchecked<K>
where
    K: Eq + std::hash::Hash + Clone + Send + Debug,
    Self: Send,
{
    /// Retrieves a batch of rows from the database given an iterator of keys
    ///
    /// Returns a collection of the retrieved rows and a set of the keys
    /// that were not found.
    ///
    /// ```no_run
    /// # use editoast_models::prelude::*;
    /// # use database::DbConnection;
    /// # use std::collections::HashSet;
    /// # #[derive(Debug, PartialEq, Eq, Hash)]
    /// # struct Document;
    /// # impl Document {
    /// #     async fn retrieve_batch<C: Default + std::iter::Extend<Self>>(
    /// #         _conn: &mut DbConnection, _ids: impl IntoIterator<Item = i64> + Send
    /// #     ) -> Result<(C, HashSet<i64>), std::io::Error> { Ok((C::default(), HashSet::new())) }
    /// # }
    /// # async fn example(mut conn: DbConnection) -> Result<(), std::io::Error> {
    /// let mut ids = (0..5).collect::<Vec<_>>();
    /// ids.push(123456789);
    /// let (docs, missing): (HashSet<_>, _) = Document::retrieve_batch(&mut conn, ids).await?;
    /// assert!(missing.contains(&123456789));
    /// assert_eq!(docs.len(), 5);
    /// # Ok(())
    /// # }
    /// ```
    async fn retrieve_batch<I, C>(
        conn: &mut DbConnection,
        ids: I,
    ) -> Result<(C, std::collections::HashSet<K>), Self::Error>
    where
        I: Send + IntoIterator<Item = K>,
        C: Send
            + Default
            + std::iter::Extend<Self>
            + std::iter::FromIterator<Self>
            + std::iter::IntoIterator<Item = Self>,
    {
        let ids = ids.into_iter().collect::<std::collections::HashSet<_>>();
        let (retrieved_ids, results): (std::collections::HashSet<_>, C) =
            Self::retrieve_batch_with_key_unchecked::<_, Vec<(_, _)>>(
                conn,
                ids.clone().into_iter(),
            )
            .await?
            .into_iter()
            .unzip();
        let missing = ids
            .difference(&retrieved_ids)
            .collect::<std::collections::HashSet<_>>();
        Ok((results, missing.into_iter().cloned().collect()))
    }

    /// Just like [RetrieveBatch::retrieve_batch] but the returned models are paired with their key
    ///
    /// ```no_run
    /// # use editoast_models::prelude::*;
    /// # use database::DbConnection;
    /// # use std::collections::{HashMap, HashSet};
    /// # #[derive(Debug, PartialEq, Eq, Hash)]
    /// # struct Document;
    /// # impl Document {
    /// #     async fn retrieve_batch_with_key<C: Default + std::iter::Extend<(i64, Self)>>(
    /// #         _conn: &mut DbConnection, _ids: impl IntoIterator<Item = i64> + Send
    /// #     ) -> Result<(C, HashSet<i64>), std::io::Error> { Ok((C::default(), HashSet::new())) }
    /// # }
    /// # async fn example(mut conn: DbConnection) -> Result<(), std::io::Error> {
    /// let mut ids = (0..5).collect::<Vec<_>>();
    /// ids.push(123456789);
    /// let (docs, missing): (HashMap<_, _>, _) = Document::retrieve_batch_with_key(&mut conn, ids).await?;
    /// assert!(missing.contains(&123456789));
    /// assert!(docs.contains_key(&1));
    /// # Ok(())
    /// # }
    /// ```
    async fn retrieve_batch_with_key<I, C>(
        conn: &mut DbConnection,
        ids: I,
    ) -> Result<(C, std::collections::HashSet<K>), Self::Error>
    where
        I: Send + IntoIterator<Item = K>,
        C: Send
            + Default
            + std::iter::Extend<(K, Self)>
            + std::iter::FromIterator<(K, Self)>
            + std::iter::IntoIterator<Item = (K, Self)>,
    {
        let ids = ids.into_iter().collect::<std::collections::HashSet<_>>();
        let (retrieved_ids, results): (std::collections::HashSet<_>, C) =
            Self::retrieve_batch_with_key_unchecked::<_, Vec<(_, _)>>(
                conn,
                ids.clone().into_iter(),
            )
            .await?
            .into_iter()
            .map(|(k, v)| (k.clone(), (k, v)))
            .unzip();
        let missing = ids
            .difference(&retrieved_ids)
            .collect::<std::collections::HashSet<_>>();
        Ok((results, missing.into_iter().cloned().collect()))
    }

    /// Retrieves a batch of rows from the database given an iterator of keys
    ///
    /// Returns a collection of the retrieved rows and fails if some rows were not found.
    /// On failure, the error returned is the result of calling `fail(missing)` where `missing`
    /// is the set of ids that were not found.
    ///
    /// ```no_run
    /// # use editoast_models::prelude::*;
    /// # use database::DbConnection;
    /// # use std::collections::HashSet;
    /// # #[derive(Debug, PartialEq, Eq, Hash)]
    /// # struct Document;
    /// # impl Document {
    /// #     async fn retrieve_batch_or_fail<C: Default + std::iter::Extend<Self>, F>(
    /// #         _conn: &mut DbConnection, _ids: impl IntoIterator<Item = i64> + Send, _fail: F
    /// #     ) -> Result<C, MyErrorType> { Ok(C::default()) }
    /// # }
    /// # #[derive(Debug)]
    /// # enum MyErrorType { DocumentsNotFound(HashSet<i64>) }
    /// # impl std::fmt::Display for MyErrorType {
    /// #     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { write!(f, "error") }
    /// # }
    /// # impl std::error::Error for MyErrorType {}
    /// # async fn example(mut conn: DbConnection) -> Result<(), MyErrorType> {
    /// let ids = (0..5).collect::<Vec<_>>();
    /// let docs: HashSet<_> = Document::retrieve_batch_or_fail(&mut conn, ids, |missing| {
    ///    MyErrorType::DocumentsNotFound(missing)
    /// }).await?;
    /// # Ok(())
    /// # }
    /// ```
    async fn retrieve_batch_or_fail<I, C, E, F>(
        conn: &mut DbConnection,
        ids: I,
        fail: F,
    ) -> Result<C, E>
    where
        I: Send + IntoIterator<Item = K>,
        C: Send
            + Default
            + std::iter::Extend<Self>
            + std::iter::FromIterator<Self>
            + std::iter::IntoIterator<Item = Self>,
        E: From<Self::Error>,
        F: FnOnce(std::collections::HashSet<K>) -> E + Send,
    {
        let (result, missing) = Self::retrieve_batch::<_, C>(conn, ids).await?;
        if missing.is_empty() {
            Ok(result)
        } else {
            Err(fail(missing))
        }
    }

    /// Just like [RetrieveBatch::retrieve_batch_or_fail] but the returned models are paired with their key
    ///
    /// ```no_run
    /// # use editoast_models::prelude::*;
    /// # use database::DbConnection;
    /// # use std::collections::{HashMap, HashSet};
    /// # #[derive(Debug, PartialEq, Eq, Hash)]
    /// # struct Document;
    /// # impl Document {
    /// #     async fn retrieve_batch_with_key_or_fail<C: Default + std::iter::Extend<(i64, Self)>, F>(
    /// #         _conn: &mut DbConnection, _ids: impl IntoIterator<Item = i64> + Send, _fail: F
    /// #     ) -> Result<C, MyErrorType> { Ok(C::default()) }
    /// # }
    /// # #[derive(Debug)]
    /// # enum MyErrorType { DocumentsNotFound(HashSet<i64>) }
    /// # impl std::fmt::Display for MyErrorType {
    /// #     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { write!(f, "error") }
    /// # }
    /// # impl std::error::Error for MyErrorType {}
    /// # async fn example(mut conn: DbConnection) -> Result<(), MyErrorType> {
    /// let ids = (0..5).collect::<Vec<_>>();
    /// let docs: HashMap<_, _> = Document::retrieve_batch_with_key_or_fail(&mut conn, ids, |missing| {
    ///   MyErrorType::DocumentsNotFound(missing)
    /// }).await?;
    /// # Ok(())
    /// # }
    /// ```
    async fn retrieve_batch_with_key_or_fail<I, C, E, F>(
        conn: &mut DbConnection,
        ids: I,
        fail: F,
    ) -> Result<C, E>
    where
        I: Send + IntoIterator<Item = K>,
        C: Send
            + Default
            + std::iter::Extend<(K, Self)>
            + std::iter::FromIterator<(K, Self)>
            + std::iter::IntoIterator<Item = (K, Self)>,
        E: From<Self::Error>,
        F: FnOnce(std::collections::HashSet<K>) -> E + Send,
    {
        let (result, missing) = Self::retrieve_batch_with_key::<_, C>(conn, ids).await?;
        if missing.is_empty() {
            Ok(result)
        } else {
            Err(fail(missing))
        }
    }
}

// Auto-impl of RetrieveBatch for all models that implement RetrieveBatchUnchecked
impl<M, K> RetrieveBatch<K> for M
where
    M: RetrieveBatchUnchecked<K>,
    K: Eq + std::hash::Hash + Clone + Send + Debug,
{
}
