use std::collections::HashSet;

use chrono::DateTime;
use chrono::Utc;
use serde::Deserialize;
use serde::Deserializer;
use serde::Serialize;
use serde_with::skip_serializing_none;
use utoipa::ToSchema;
use utoipa::openapi::ObjectBuilder;
use utoipa::openapi::RefOr;
use utoipa::openapi::schema::Schema;

use crate::primitives::NonBlankString;
use crate::primitives::PositiveDuration;
use crate::rolling_stock::TrainCategory;
use crate::train_schedule::Comfort;
use crate::train_schedule::Distribution;
use crate::train_schedule::Margins;
use crate::train_schedule::PathItem;
use crate::train_schedule::PowerRestrictionItem;
use crate::train_schedule::ScheduleItem;
use crate::train_schedule::TrainSchedule;
use crate::train_schedule::TrainScheduleOptions;

#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize, ToSchema)]
pub struct Paced {
    /// Duration of the paced train, an ISO 8601 format is expected
    pub time_window: PositiveDuration,
    /// Time between two occurrences, an ISO 8601 format is expected
    pub interval: PositiveDuration,
}

#[derive(Debug, Clone, Serialize, PartialEq, ToSchema)]
pub struct PacedTrain {
    #[serde(flatten)]
    pub train_schedule_base: TrainSchedule,
    #[schema(inline)]
    pub paced: Paced,
    #[serde(default)]
    #[schema(required)]
    pub exceptions: Vec<PacedTrainException>,
}

impl<'de> Deserialize<'de> for PacedTrain {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: Deserializer<'de>,
    {
        #[derive(Deserialize)]
        struct PacedTrainJson {
            #[serde(flatten)]
            pub train_schedule_base: TrainSchedule,
            pub paced: Paced,
            #[serde(default)]
            pub exceptions: Vec<PacedTrainException>,
        }
        let raw = PacedTrainJson::deserialize(deserializer)?;

        let mut seen_keys = HashSet::with_capacity(raw.exceptions.len());
        for e in &raw.exceptions {
            if !seen_keys.insert(&e.key) {
                return Err(serde::de::Error::custom(format!(
                    "Duplicate exception key: '{}'",
                    e.key
                )));
            }
        }

        let time_window_secs = raw.paced.time_window.num_seconds();
        let interval_secs = raw.paced.interval.num_seconds();
        let num_occurrences = (time_window_secs / interval_secs) as usize;

        for ex in &raw.exceptions {
            if let ExceptionType::Modified { occurrence_index } = ex.exception_type
                && occurrence_index as usize > num_occurrences
            {
                return Err(serde::de::Error::custom(format!(
                    "Modified exception '{}' references invalid occurrence index {}",
                    ex.key, occurrence_index,
                )));
            }
        }

        Ok(PacedTrain {
            train_schedule_base: raw.train_schedule_base,
            paced: raw.paced,
            exceptions: raw.exceptions,
        })
    }
}

/// Represents an exception for a paced train occurrence.
/// Occurrences are normally generated from a base paced train.
/// An exception occurs when an occurrence is added or modified
/// compared to the base model. Each field corresponds to a "ChangeGroup" of attributes
/// that may deviate from the paced train.
/// - Created: A new occurrence manually added by the user, not originally present in the automatically generated occurrences based on the paced train.
/// - Modified: An existing occurrence that has been changed
#[skip_serializing_none]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, ToSchema)]
#[cfg_attr(feature = "testing", derive(Default))]
pub struct PacedTrainException {
    /// Unique key for the exception within the paced train, required and generated by the frontend.
    pub key: String,
    #[serde(flatten)]
    #[schema(inline)]
    pub exception_type: ExceptionType,
    #[serde[default]]
    pub disabled: bool,
    #[schema(nullable = false)]
    pub train_name: Option<TrainNameChangeGroup>,
    #[schema(nullable = false)]
    pub rolling_stock: Option<RollingStockChangeGroup>,
    #[schema(nullable = false)]
    pub rolling_stock_category: Option<RollingStockCategoryChangeGroup>,
    #[schema(nullable = false)]
    pub labels: Option<LabelsChangeGroup>,
    #[schema(nullable = false)]
    pub speed_limit_tag: Option<SpeedLimitTagChangeGroup>,
    #[schema(nullable = false)]
    pub start_time: Option<StartTimeChangeGroup>,
    #[schema(nullable = false)]
    pub constraint_distribution: Option<ConstraintDistributionChangeGroup>,
    #[schema(nullable = false)]
    pub initial_speed: Option<InitialSpeedChangeGroup>,
    #[schema(nullable = false)]
    pub options: Option<OptionsChangeGroup>,
    #[schema(nullable = false)]
    pub path_and_schedule: Option<PathAndScheduleChangeGroup>,
}

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
#[serde(untagged)]
pub enum ExceptionType {
    Modified { occurrence_index: i32 },
    // Created is a struct variant (not unit) to allow proper deserialization with #[serde(untagged)].
    // This avoids ambiguity with an empty object `{}`.
    // Must be declared after more specific variants, as order matters for untagged enums.
    Created {},
}

#[cfg(feature = "testing")]
impl Default for ExceptionType {
    fn default() -> Self {
        ExceptionType::Created {}
    }
}

impl utoipa::PartialSchema for ExceptionType {
    fn schema() -> RefOr<Schema> {
        let modified_schema = ObjectBuilder::new()
            .property(
                "occurrence_index",
                ObjectBuilder::new().schema_type(utoipa::openapi::schema::SchemaType::Type(
                    utoipa::openapi::schema::Type::Integer,
                )),
            )
            .build();
        modified_schema.into()
    }
}

impl ToSchema for ExceptionType {}

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, ToSchema)]
pub struct TrainNameChangeGroup {
    pub value: String,
}

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, ToSchema)]
pub struct RollingStockChangeGroup {
    pub rolling_stock_name: String,
    pub comfort: Comfort,
}

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, ToSchema)]
pub struct RollingStockCategoryChangeGroup {
    pub value: Option<TrainCategory>,
}

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, ToSchema)]
pub struct LabelsChangeGroup {
    pub value: Vec<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, ToSchema)]
pub struct SpeedLimitTagChangeGroup {
    #[schema(inline)]
    pub value: Option<NonBlankString>,
}

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, ToSchema)]
pub struct StartTimeChangeGroup {
    pub value: DateTime<Utc>,
}

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, ToSchema)]
pub struct ConstraintDistributionChangeGroup {
    pub value: Distribution,
}

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, ToSchema)]
pub struct InitialSpeedChangeGroup {
    pub value: f64,
}

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, ToSchema)]
pub struct OptionsChangeGroup {
    pub value: TrainScheduleOptions,
}

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, ToSchema)]
pub struct PathAndScheduleChangeGroup {
    pub path: Vec<PathItem>,
    pub schedule: Vec<ScheduleItem>,
    pub margins: Margins,
    pub power_restrictions: Vec<PowerRestrictionItem>,
}
