# OSRD's Simulation backend

This is the service in charge of handling the core railway logic
and physics simulations.

It can currently handle:

* Pathfinding operations
* Train simulations (including both speed / running times,
and the simulation of nearby signaling)
* Conflict detection
* Last minute train requests
* Path properties / projection operations


What **is not** supported yet:

* Multi-train simulations, where each train react to their
surroundings


The API itself isn't extensively documented in an openapi file
or similar (that's one big TODO). Existing endpoints are listed in
the `WorkerCommand.kt` file, and the inputs/outputs are described
in their respective classes. Note: some numerical values have their
own types, such as `Distance`. See their docstring for the
expected unit and underlying type (generally Long and mm/ms).


## Getting Started

You'll need **Java 21**


### Server usage (preferred)

```sh
# on Linux / MacOS
./gradlew shadowJar

# on Windows
gradlew.bat shadowJar

# Run as a RabbitMQ single worker for all infra
ALL_INFRA=true java -jar build/libs/osrd-all.jar worker --editoast-url http://localhost:8090/

# Check that an infra can be loaded
java -jar build/libs/osrd-all.jar load-infra --path infra.json

# Run as web-service (deprecated inside OSRD's stack)
java -jar build/libs/osrd-all.jar api --editoast-url http://localhost:8090/ --port 8080
```

### CLI usage (alternative)

```sh
# on Linux / MacOS
./gradlew shadowJar

# on Windows
gradlew.bat shadowJar

# Run a simulation. You can use the files generated by the previous command
# in ./build/generated_examples/small_infra for an example of the formats used.
java -jar build/libs/osrd-all.jar standalone-simulation --infra_path example/infra.json \
      --sim_path example/simulation.json --res_path example/results.json
```

### Tests and tooling

To launch all the checks on core (tests and code quality), run:

```sh
./gradlew check
```

To launch tests only, run:

```sh
./gradlew test
```

To auto-format all source code (required for the CI checks to pass), run:

```sh
./gradlew spotlessApply
```


### Local run and debug

It is recommended to pass additional Java options to enable the process of big infra:

```sh
-ea -Xmx12g -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=dump.hprof
```

* `-ea` enables assertions (used extensively in the project).
* `-Xmx12g` increases the allowed RAM usage to 12g (tweak this value for your use)
* `-XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=dump.hprof` is only relevant for memory use debugging
(but never hurts). It dumps useful files when hitting the RAM limit.

Using a specific script (just through `docker compose` CLI and a set of docker-compose files)
allows to run a single core worker for all infra on localhost network:

```sh
./osrd-compose host sw up -d

# or exclude 'core' service straight away:
./osrd-compose host sw up -d --scale core=0
```

Then, it is easy to replace the desired component for debug purpose. \
For core:

```sh
./osrd-compose host sw down core # if 'core' is running
./gradlew shadowJar && ALL_INFRA=true java -jar -ea -Xmx12g -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=dump.hprof build/libs/osrd-all.jar worker --editoast-url http://localhost:8090/
```

For STDCM tests, it's possible to store (heavy) timetable data locally to save
important I/O time.
Set `LOCAL_TIMETABLE_CACHE` to some location (like `timetable_cache`) where
core will read timetable cache (or create for later use).
If timetables can be modified between STDCM requests, `DISABLE_ALL_TIMETABLE_CACHE`
should be set to `true`, as there's currently no cache invalidation.

No-cache mode on editoast is also usually helpful to repeat requests. \
One may want to combine it with single-worker mode and probably manage authz. \
Please check [editoast's README](../editoast/README.md) for all that.


Clean or restart the whole stack can be necessary sometimes and is also available
through docker compose CLI (the following wipes the database too):
```sh
./osrd-compose host sw down -v
```


### Development tips

The most important interfaces/classes are the ones describing the infrastructure:
`RawInfra` and `BlockInfra`. They work through abstract accessors and IDs
instead of nested object (the plan being to enable possible future FFI there).
The downside is that we can't just view object properties in the debugger, but the
functions in `DebugViewers` can map IDs to nested objects for this purpose.

We do our best to type numerical values, using inlined value types such as `Distance`
or `Duration`. Type mismatches would fail to compile. Object offsets are typed with
the reference object, using `Offset<T>`.

Requests processed by the worker can be written to disk by setting these environments
variables to true: `LOG_STDCM_REQUESTS`, `LOG_PATHFINDING_REQUESTS`,
`LOG_SIMULATION_REQUESTS`. Though be careful, STDCM payload can be large
(possibly in the 100s of MB). They can then be reproduced by the
`reproduce-request` CLI command.
