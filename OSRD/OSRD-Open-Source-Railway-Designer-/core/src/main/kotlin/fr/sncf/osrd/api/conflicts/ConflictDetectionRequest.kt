package fr.sncf.osrd.api.conflicts

import com.squareup.moshi.Json
import com.squareup.moshi.JsonAdapter
import com.squareup.moshi.Moshi
import com.squareup.moshi.kotlin.reflect.KotlinJsonAdapterFactory
import fr.sncf.osrd.api.RJSRoutingRequirement
import fr.sncf.osrd.api.RJSSpacingRequirement
import fr.sncf.osrd.api.WorkSchedule
import fr.sncf.osrd.utils.json.UnitAdapterFactory
import java.time.ZonedDateTime

class ConflictDetectionRequest(
    /** Infra ID. */
    var infra: String,
    /** Expected infra version, used for cache invalidation. */
    @Json(name = "expected_version") var expectedVersion: Int,
    /**
     * Map of train id -> train requirements. The train requirements should be generated by the
     * simulation endpoint.
     */
    @Json(name = "trains_requirements")
    val trainsRequirements: Map<String, TrainRequirementsRequest>,
    /** Work schedules, if any. */
    @Json(name = "work_schedules") val workSchedules: WorkSchedulesRequest? = null,
)

/** Describes the requirements needed for a given train to run without any delay. */
open class TrainRequirementsRequest(
    /**
     * Start time for the given train. Acts as a reference point for all time values in the spacing
     * and routing requirements for this train (values expressed as time delta).
     */
    @Json(name = "start_time") val startTime: ZonedDateTime,
    /**
     * Spacing requirements for the given train (i.e. which zones need to be free in which time
     * ranges).
     */
    @Json(name = "spacing_requirements") val spacingRequirements: Collection<RJSSpacingRequirement>,
    /**
     * Routing requirements for the given train (i.e. which routes need to be usable in which time
     * ranges).
     */
    @Json(name = "routing_requirements") val routingRequirements: Collection<RJSRoutingRequirement>,
)

// TODO: use this class in conflict detection endpoint rather than Map<Long,
// TrainRequirementsRequest>
class TrainRequirementsById(
    @Json(name = "train_id") val trainId: String,
    @Json(name = "start_time") startTime: ZonedDateTime,
    @Json(name = "spacing_requirements") spacingRequirements: Collection<RJSSpacingRequirement>,
    @Json(name = "routing_requirements") routingRequirements: Collection<RJSRoutingRequirement>,
) : TrainRequirementsRequest(startTime, spacingRequirements, routingRequirements)

/** Describes the set of work schedules in the given timetable. */
class WorkSchedulesRequest(
    /**
     * Reference time for other time values in the work schedule requirements (expressed as time
     * deltas).
     */
    @Json(name = "start_time") val startTime: ZonedDateTime,
    /** Map of work schedule id -> work schedule data. */
    @Json(name = "work_schedule_requirements")
    val workScheduleRequirements: Map<String, WorkSchedule>,
)

val conflictRequestAdapter: JsonAdapter<ConflictDetectionRequest> =
    Moshi.Builder()
        .addLast(UnitAdapterFactory())
        .addLast(KotlinJsonAdapterFactory())
        .build()
        .adapter(ConflictDetectionRequest::class.java)
